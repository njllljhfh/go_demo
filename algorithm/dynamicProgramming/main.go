package main

import "fmt"

/*
动态规划

动态规划解题套路框架
https://labuladong.online/algo/essential-technique/dynamic-programming-framework/

虽然动态规划的核心思想就是穷举求最值，但是问题可以千变万化，穷举所有可行解其实并不是一件容易的事，
需要你熟练掌握递归思维，只有列出正确的「状态转移方程」，才能正确地穷举。
而且，你需要判断算法问题是否具备「最优子结构」，是否能够通过子问题的最值得到原问题的最值。
另外，动态规划问题存在「重叠子问题」，如果暴力穷举的话效率会很低，所以需要你使用「备忘录」或者「DP table」来优化穷举过程，避免不必要的计算。
以上提到的 状态转移方程、最优子结构、重叠子问题 就是动态规划三要素。
*/

// fib1 通过斐波那契数列，初识 动态规划 算法
func fib1(N int) int {
    // 备忘录全初始化为 0
    memo := make([]int, N+1)
    // 进行带备忘录的递归
    return dp1(memo, N)
}

// 自顶向下递归的动态规划
// dp1 带着备忘录进行递归
// 时间复杂度：O(n)
// 空间复杂度：O(n)
func dp1(memo []int, n int) int {
    // base case
    if n == 0 || n == 1 {
        return n
    }
    // 已经计算过，不用再计算了
    if memo[n] != 0 {
        return memo[n]
    }
    memo[n] = dp1(memo, n-1) + dp1(memo, n-2)
    return memo[n]
}

// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

// fib2 自底向上的 dp 数组的迭代（递推）解法
// 时间复杂度：O(n)
// 空间复杂度：O(n)
func fib2(N int) int {
    if N == 0 {
        return 0
    }

    // dp table
    dp := make([]int, N+1)

    // base case
    dp[0], dp[1] = 0, 1

    // 状态转移
    for i := 2; i <= N; i++ {
        dp[i] = dp[i-1] + dp[i-2]
    }

    return dp[N]
}

// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

// 细心的读者会发现，根据斐波那契数列的状态转移方程，当前状态 n 只和之前的 n-1, n-2 两个状态有关，
// 其实并不需要那么长的一个 DP table 来存储所有的状态，只要想办法存储之前的两个状态就行了。
// 所以，可以进一步优化，把空间复杂度降为 O(1)。这也就是我们最常见的计算斐波那契数的算法：
// 时间复杂度：O(n)
// 空间复杂度：O(1)
func fib3(n int) int {
    if n == 0 || n == 1 {
        // base case
        return n
    }
    // 分别代表 dp[i - 1] 和 dp[i - 2]
    dpIMinus1, dpIMinus2 := 1, 0
    for i := 2; i <= n; i++ {
        // dp[i] = dp[i - 1] + dp[i - 2];
        dpI := dpIMinus1 + dpIMinus2
        // 滚动更新
        dpIMinus2 = dpIMinus1
        dpIMinus1 = dpI
    }
    return dpIMinus1
}

/*
这一般是动态规划问题的最后一步优化，如果我们发现每次状态转移只需要 DP table 中的一部分，
那么可以尝试缩小 DP table 的大小，只记录必要的数据，从而降低空间复杂度。

上述例子就相当于把 DP table 的大小从 n 缩小到 2，即把空间复杂度下降了一个量级。我会在后文
对动态规划发动降维打击 进一步讲解这个压缩空间复杂度的技巧，一般来说用来把一个二维的 DP table 压缩成一维，即把空间复杂度从 O(n^2) 压缩到 O(n)。

有人会问，动态规划的另一个重要特性「最优子结构」，怎么没有涉及？下面会涉及。
斐波那契数列的例子严格来说不算动态规划，因为没有涉及求最值，以上旨在说明重叠子问题的消除方法，演示得到最优解法逐步求精的过程。
下面，看第二个例子，凑零钱问题。
*/

/*
计算机解决问题其实没有任何特殊的技巧，它唯一的解决办法就是穷举，穷举所有可能性。
算法设计无非就是先思考"如何穷举"，然后再追求"如何聪明地穷举"。

列出状态转移方程，就是在解决“如何穷举”的问题。之所以说它难，一是因为很多穷举需要递归实现，二是因为有的问题本身的解空间复杂，不那么容易穷举完整。

备忘录、DP table 就是在追求“如何聪明地穷举”。用空间换时间的思路，是降低时间复杂度的不二法门，除此之外，试问，还能玩出啥花活？
---------------------------

在阅读每个题目和解法时，多往「状态」和「选择」上靠，才能对这套框架产生自己的理解，运用自如。
*/

func main() {
    // fmt.Println(fib1(5))
    // fmt.Println(fib2(5))
    fmt.Println(fib3(5))
}
